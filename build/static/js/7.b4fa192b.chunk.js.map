{"version":3,"sources":["app/wireworks/networking/byte.ts","app/wireworks/utils/math.ts","app/wireworks/networking/layers/layer-3/address.ts","app/wireworks/utils/dom.ts","app/wireworks/utils/string.ts","app/pages/tools/layer-3/ipbits.tsx"],"names":["ByteZero","Byte","ByteMax","ERROR_BYTE_RANGE","value","Object","_home_void_Documents_wireworks_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","bits","decimal","setDecimal","setBits","_home_void_Documents_wireworks_github_io_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","key","Math","floor","err","RangeError","name","arr","length","bit8","i","undefined","booleanArrayToBit8","decimalToBinary","binaryToDecimal","index","arguments","slice","clamp","min","max","binary","reversed","realIndex","pow","tmpDecimal","reverse","__webpack_require__","d","__webpack_exports__","Byte4Zero","cloneByte4","byte4","clone","ERROR_MASK_RANGE","ERROR_ADDRESS_PARSE","ERROR_NOT_NETWORK","joinBitIndex","byteIndex","bitIndex","splitBitIndex","byte4Index","Address","ip","mask","requireMask","requireNetwork","maskShort","parseAddress","setMaskShort","setMask","isNetworkAddress","Error","bytes","Array","minByte","maskByte","bit","maxByte","allowAbove30","compare","getNetworkAddress","getBroadcastAddress","other","j","ipBytes","maskBytes","net","getDecimal","subnets","secondIpBytes","_splitBitIndex","maskShortTmp","end","tmpMask","address","trim","match","exec","ipByte0","parseInt","ipByte1","ipByte2","ipByte3","setIp","matchIp","omitMask","shortMaskString","getMaskShort","copyToClipboard","str","done","tmp","document","createElement","style","position","top","left","opacity","body","appendChild","focus","select","success","execCommand","removeChild","NUMBERS","isCharNumeric","indexOf","additionalKeys","Ipbits","props","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","IP","MASK","maskDisplays","ipDisplays","ipDisplayShort","maskDisplayShort","copyMaskButton","copyIPButton","copyMaskText","copyIPText","updateDisplays","extractAddress","current","getIp","textContent","getMask","updateIPShort","toString","updateMaskShort","selectMaskBit","checked","_splitBitIndex2","on","disabled","copyIPToClipboard","scope","assertThisInitialized","text","transition","setTimeout","copyMaskToClipboard","maskString","handleIPBitChange","handleMaskBitChange","blurByte","handleDisplayFocus","display","originalAddress","handleDisplayBlur","setIPByteDOM","handleDisplayKeydown","evt","blur","selectedText","window","getSelection","anchorNode","parentNode","preventDefault","handleDisplayKeyup","next","handleDisplayChange","charAt","isStringNumeric","React","createRef","byte","updateBig","updateShort","dom","_this2","maskBox","ipBox","_loop","bitBox","_loop3","id","push","react_default","a","className","tabIndex","ref","type","onChange","htmlFor","_loop2","ipDisplay","onFocus","onBlur","onKeyDown","onKeyUp","onClick","Component"],"mappings":"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","file":"static/js/7.b4fa192b.chunk.js","sourcesContent":["import { decimalToBinary, binaryToDecimal } from \"../utils/math\";\n\n/**\n * An array of 8 bits (boolean values).\n */\nexport type Bit8 = [boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean];\n\n/**\n * Returns a Bit8 filled with false.\n */\nexport function Bit8Zero(): Bit8 {\n\treturn [false, false, false, false, false, false, false, false];\n}\n\n/**\n * Returns a Bit8 filled with true.\n */\nexport function Bit8Max(): Bit8 {\n\treturn [true, true, true, true, true, true, true, true];\n}\n\n/**\n * Returns a Byte corresponding to the number 0.\n */\nexport function ByteZero(): Byte {\n\treturn new Byte(Bit8Zero());\n}\n\n/**\n * Returns a Byte corresponding to the number 255.\n */\nexport function ByteMax(): Byte {\n\treturn new Byte(Bit8Max());\n}\n\nexport function booleanArrayToBit8 (arr: boolean[]): Bit8 {\n\tif (arr.length > 8) {\n\t\tthrow new RangeError(\"The boolean array must have a length of 8 or less\");\n\t}\n\tlet bit8: Bit8 = Bit8Zero();\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tbit8[i] = arr[i] !== undefined ? arr[i] : false;\n\t}\n\treturn bit8;\n}\n\n/**\n * Error name for a byte outside the correct range.\n */\nexport const ERROR_BYTE_RANGE = \"ByteRangeError\";\n\n/**\n * A Byte, composed of 8 bits (boolean values).\n * @author Henrique Colini\n */\nexport class Byte {\n\n\t/**\n\t * This Byte's Bit8 representation.\n\t */\t\n\tprivate bits: Bit8;\n\n\t/**\n\t * This Byte's numerical representation.\n\t */\n\tprivate decimal: number;\n\t\n\t/**\n\t * Constructs a Byte from a number (0-255) or a Bit8.\n\t * @constructor\n\t * @param  {number|Bit8} value The value of this Byte.\n\t */\n\n\tconstructor(value: number | Bit8) {\n\n\t\tif (typeof value === \"number\") {\n\t\t\tthis.setDecimal(value);\n\t\t}\n\t\telse {\n\t\t\tthis.setBits(value);\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets the value of this Byte, using a number (0-255).\n\t * @param  {number} decimal\n\t */\n\n\tsetDecimal(decimal: number): void {\n\n\t\tif (decimal < 0 || decimal > 255 || decimal !== Math.floor(decimal)) {\n\t\t\tlet err = new RangeError(\"The decimal value of a byte must be an integer between 0-255 (inclusive)\");\n\t\t\terr.name = ERROR_BYTE_RANGE;\n\t\t\tthrow err;\n\t\t}\n\n\t\tthis.bits = booleanArrayToBit8(decimalToBinary(decimal));\n\t\tthis.decimal = decimal;\n\n\t}\n\n\t/**\n\t * Sets the value of this Byte, using a Bit8.\n\t * @param  {Bit8} bits\n\t */\n\n\tsetBits(bits: Bit8): void {\n\n\t\tthis.bits = bits;\n\t\tthis.decimal = binaryToDecimal(bits);\n\n\t}\n\n\t/**\n\t * Returns this Byte's numeric value.\n\t */\n\n\tgetDecimal(): number {\n\t\treturn this.decimal;\n\t}\n\n\t/**\n\t * Returns this Byte's Bit8 representation.\n\t */\n\n\tgetBits(): Bit8 {\n\t\treturn this.bits;\n\t}\n\n\t/**\n\t * Getter/Setter of a single bit from this Byte.\n\t * @param  {number} index The index of the bit.\n\t * @param  {boolean|undefined=undefined} value Optional. Sets the value for this bit.\n\t */\n\n\tbit(index: number, value: boolean | undefined = undefined): boolean {\n\n\t\tif (value !== undefined) {\n\t\t\tlet bits = this.bits;\n\t\t\tbits[index] = value;\n\t\t\tthis.setBits(bits);\n\t\t}\n\n\t\treturn this.bits[index];\n\n\t}\n\n\t/**\n\t * Clones this Byte.\n\t */\n\tclone(): Byte {\n\n\t\treturn new Byte(this.bits.slice() as Bit8)\n\n\t}\n\n}","/**\n * Returns a value, clamped between max and min.\n * @param  {number} value The number to be clamped.\n * @param  {number} min The minimum possible number.\n * @param  {number} max The maximum possible number.\n */\nexport function clamp(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n};\n\n/**\n * Converts a binary number (as a string, boolean array, or number array) to a decimal number.\n * @param  {boolean[]} binary The number to be converted. An array of booleans, read from left to right (e.g. 001 equals 4).\n * @param  {boolean} reversed Optional. Whether the input should be reversed (read from right to left). Defaults to false.\n */\nexport function binaryToDecimal(binary: boolean[], reversed: boolean = false): number {\n\n\tif (binary.length === 0) {\n\t\treturn 0;\n\t}\n\n\tlet decimal = 0;\n\n\tfor (let realIndex = 0; realIndex < binary.length; realIndex++) {\n\n\t\tlet i = reversed ? binary.length - realIndex - 1 : realIndex;\n\n\t\tdecimal += binary[i] ? Math.pow(2, i) : 0;\n\t\t\n\t}\n\n\treturn decimal;\n\t\n}\n\n/**\n * Converts a decimal number (must be a positive integer) to an array of booleans (read from left to right, such that 001 equals 4).\n * @param  {number} decimal The number to be converted. Must be a positive integer.\n * @param  {boolean} reversed Optional. Whether the output should be reversed (read from right to left). Defaults to false.\n */\nexport function decimalToBinary(decimal: number, reversed: boolean = false): boolean[] {\n\n\tif (decimal < 0) {\n\t\tthrow new RangeError(\"Attempting to convert negative number to binary\");\n\t}\n\n\tif (decimal !== Math.floor(decimal)) {\n\t\tthrow new RangeError(\"Attempting to convert non-integer number to binary\");\n\t}\n\n\tlet binary: boolean[] = [];\n\n\tlet tmpDecimal = decimal, i = 0;\n\n\twhile (tmpDecimal > 0) {\n\n\t\tbinary[i] = tmpDecimal % 2 ? true : false;\n\t\ttmpDecimal = Math.floor(tmpDecimal / 2);\n\n\t\ti++;\n\n\t}\n\n\tif (reversed) {\n\t\tbinary.reverse();\n\t}\n\n\treturn binary;\n\n}","import { Byte, ByteZero, ByteMax } from \"../../byte\";\n\n/**\n * An array of 4 Bytes.\n */\nexport type Byte4 = [Byte,Byte,Byte,Byte];\n\n/**\n * Returns a Byte4 corresponding to 0, 0, 0, 0.\n */\nexport function Byte4Zero(): Byte4 {\n\treturn [ByteZero(), ByteZero(), ByteZero(), ByteZero()];\n}\n\n/**\n * Returns a Byte4 corresponding to 255, 255, 255, 255.\n */\nexport function Byte4Max(): Byte4 {\n\treturn [ByteMax(), ByteMax(), ByteMax(), ByteMax()];\n}\n\n/**\n * Clones a Byte4.\n * @param  {Byte4} byte4 The Byte4 to be cloned.\n */\nexport function cloneByte4(byte4: Byte4): Byte4 {\n\n\tbyte4 = byte4.slice() as Byte4;\n\n\tfor (let i = 0; i < 4; i++) {\n\t\tbyte4[i] = byte4[i].clone();\t\t\n\t}\n\n\treturn byte4;\n\n}\n\n/**\n * Error name for a mask with holes.\n */\nexport const ERROR_MASK_HOLES = \"MaskHolesError\";\n/**\n * Error name for a mask outside the correct range.\n */\nexport const ERROR_MASK_RANGE = \"MaskRangeError\";\n/**\n * Error name for a malformated address string.\n */\nexport const ERROR_ADDRESS_PARSE = \"AddressParseError\";\n/**\n * Error name for a when an Address should be a Network Address, but isn't.\n */\nexport const ERROR_NOT_NETWORK = \"NotNetworkError\";\n\n/**\n * Converts a bit in Byte index to a bit in Byte4 index.\n * @param  {number} byteIndex The index of the Byte in a Byte4.\n * @param  {number} bitIndex The index of the bit in the Byte.\n */\nexport function joinBitIndex(byteIndex: number, bitIndex: number): number {\n\tif (byteIndex > 3 || byteIndex < 0) {\n\t\tthrow new RangeError(\"The byteIndex must be between 0-3 (inclusive)\");\n\t}\n\tif (bitIndex > 7 || bitIndex < 0) {\n\t\tthrow new RangeError(\"The bitIndex must be between 0-7 (inclusive)\");\n\t}\n\treturn (8 * byteIndex) + (7 - bitIndex);\n}\n\n/**\n * Converts a bit in Byte4 index to a bit in Byte index.\n * @param  {number} byte4Index The index of the bit in a Byte4.\n */\nexport function splitBitIndex(byte4Index: number): { byteIndex: number, bitIndex: number } {\n\tif (byte4Index > 31 || byte4Index < 0) {\n\t\tthrow new RangeError(\"The byte4Index must be between 0-31 (inclusive)\");\n\t}\n\treturn {\n\t\tbyteIndex: Math.floor(byte4Index / 8),\n\t\tbitIndex: 7 - (byte4Index % 8)\n\t};\n}\n\n/**\n * A full IP/Mask address.\n * @author Henrique Colini\n */\nexport class Address {\n\t\n\t/**\n\t * This Address' IP.\n\t */\n\tprivate ip: Byte4;\n\n\t/**\n\t * This Address' mask.\n\t */\n\tprivate mask: Byte4;\n\n\t/**\n\t * The numerical representation of this Address' mask.\n\t */\n\tprivate maskShort: number;\n\n\t\n\t/**\n\t * Constructs an Address, given an IP and a mask.\n\t * @constructor\n\t * @param  {Byte4|string} ip The IP of this Address. May be a Byte4 or a formatted string.\n\t * @param  {Byte4|number} mask Optional. The mask of this Address. May be a Byte4 or its numerical representation. If not given, defaults to /0.\n\t * @param  {boolean} requireMask Optional. If set to true, the mask becomes a required parameter in the formatted string.\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a Network Address. Defaults to false.\n\t */\n\tconstructor(ip: Byte4 | string, mask?: Byte4 | number, requireMask: boolean = false, requireNetwork: boolean = false) {\n\n\t\tif (typeof ip === \"string\") {\n\t\t\tthis.parseAddress(ip, requireMask);\n\t\t}\n\t\telse {\n\t\t\tthis.ip = ip;\n\t\t}\n\n\t\tif (!this.mask) {\n\t\t\tif (mask) {\n\t\t\t\tif (typeof mask === \"number\") {\n\t\t\t\t\tthis.setMaskShort(mask);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.setMask(mask);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.setMask(Byte4Zero());\n\t\t\t}\n\t\t}\n\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\n\t\t\tlet err = new Error(\"Not a Network Address\");\n\t\t\terr.name = ERROR_NOT_NETWORK;\n\t\t\tthrow err;\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns the Network Address of this Address.\n\t * @param {boolean} allowAbove30 Optional. If false, returns undefined if the mask is greater than 30. Defaults to false.\n\t */\n\tpublic getNetworkAddress(allowAbove30: boolean = false): Address {\n\n\t\tif (!allowAbove30 && this.maskShort > 30) return undefined;\n\n\t\tlet bytes: Byte4 = Array<Byte>(4) as Byte4;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\n\t\t\tlet minByte = this.ip[i].clone();\n\t\t\tlet maskByte = this.mask[i];\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif (!maskByte.bit(i)) {\n\t\t\t\t\tminByte.bit(i, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbytes[i] = minByte;\n\n\t\t}\n\n\t\treturn new Address(bytes, cloneByte4(this.mask));\n\n\t}\n\n\t/**\n\t * Returns the Broadcast Address of this Address' network.\n\t * @param {boolean} allowAbove30 Optional. If false, returns undefined if the mask is greater than 30. Defaults to false.\n\t */\n\tpublic getBroadcastAddress(allowAbove30: boolean = false): Address {\n\n\t\tif (!allowAbove30 && this.maskShort > 30) return undefined;\n\n\t\tlet bytes: Byte4 = Array<Byte>(4) as Byte4;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\n\t\t\tlet maxByte = this.ip[i].clone();\n\t\t\tlet maskByte = this.mask[i];\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif (!maskByte.bit(i)) {\n\t\t\t\t\tmaxByte.bit(i, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbytes[i] = maxByte;\n\n\t\t}\n\n\t\treturn new Address(bytes, cloneByte4(this.mask));\n\n\t}\n\t\n\t/**\n\t * Returns whether this Address is a Network Address.\n\t * @param {boolean} allowAbove30 Optional. If false, returns false if the mask is greater than 30. Defaults to false.\n\t */\n\tpublic isNetworkAddress(allowAbove30: boolean = false): boolean {\n\t\treturn this.compare(this.getNetworkAddress(allowAbove30));\n\t};\n\n\t/**\n\t * Returns whether this Address is a Broadcast Address.\n\t * @param {boolean} allowAbove30 Optional. If false, returns false if the mask is greater than 30. Defaults to false.\n\t */\n\tpublic isBroadcastAddress(allowAbove30: boolean = false): boolean {\n\t\treturn this.compare(this.getBroadcastAddress(allowAbove30));\n\t};\n\t\n\t/**\n\t * Returns true if this Address is the same as another.\n\t * @param {Address} other the Address to be compared with.\n\t */\n\tpublic compare(other: Address): boolean {\n\n\t\tif (!other) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this === other)\n\t\t\treturn true;\n\n\t\tif (this.ip === other.ip && (this.mask === other.mask || this.maskShort === other.maskShort))\n\t\t\treturn true;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tfor (let j = 0; j < 8; j++) {\n\t\t\t\tif ((this.ip[i].bit(j) !== other.ip[i].bit(j)) || (this.mask[i].bit(j) !== other.mask[i].bit(j))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\n\t\treturn true;\n\n\t}\n\t\n\t/**\n\t * Returns the amount of hosts that this Address' network has.\n\t * @param {boolean} requireNetwork Optional. If true, throws an error if this is not a Network Address. Defaults to false.\n\t */\n\tpublic numberOfHosts(requireNetwork: boolean = false): number {\n\n\t\tif(requireNetwork && !this.isNetworkAddress(true)) {\n\t\t\tlet err = new Error(\"Not a Network Address\");\n\t\t\terr.name = ERROR_NOT_NETWORK;\n\t\t\tthrow err;\n\t\t}\n\n\t\tif (this.maskShort === 31)\n\t\t\treturn 2;\n\t\tif (this.maskShort === 32)\n\t\t\treturn 1;\n\t\treturn (Math.pow(2, 32 - this.maskShort) - 2);\n\n\t}\n\n\t/**\n\t * Returns the first valid host Address of this network.\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a Network Address. Defaults to false.\n\t */\n\tpublic firstHost(requireNetwork: boolean = false): Address {\n\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\n\t\t\tlet err = new Error(\"Not a Network Address\");\n\t\t\terr.name = ERROR_NOT_NETWORK;\n\t\t\tthrow err;\n\t\t}\n\n\t\tlet ipBytes: Byte4;\n\t\tlet maskBytes: Byte4;\n\n\t\tif (requireNetwork) {\n\t\t\tipBytes = cloneByte4(this.ip);\n\t\t\tmaskBytes = cloneByte4(this.mask);\n\t\t}\n\t\telse {\n\t\t\tlet net = this.getNetworkAddress(true);\n\t\t\tipBytes = net.ip;\n\t\t\tmaskBytes = net.mask;\n\t\t}\n\n\t\tif (this.maskShort < 31) {\n\t\t\tipBytes[3].setDecimal(ipBytes[3].getDecimal() + 1);\n\t\t}\n\n\t\treturn new Address(ipBytes, maskBytes);\n\n\t}\n\n\t/**\n\t * Returns the last valid host Address of this network.\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a Network Address. Defaults to false.\n\t */\n\tpublic lastHost(requireNetwork: boolean = false): Address {\n\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\n\t\t\tlet err = new Error(\"Not a Network Address\");\n\t\t\terr.name = ERROR_NOT_NETWORK;\n\t\t\tthrow err;\n\t\t}\n\n\t\tlet ipBytes: Byte4;\n\t\tlet maskBytes: Byte4;\n\n\t\tlet net = this.getBroadcastAddress(true);\n\t\tipBytes = net.ip;\n\t\tmaskBytes = net.mask;\n\n\t\tif (this.maskShort < 31) {\n\t\t\tipBytes[3].setDecimal(ipBytes[3].getDecimal() - 1);\n\t\t}\n\n\t\treturn new Address(ipBytes, maskBytes);\n\n\t}\n\n\t/**\n\t * Divides this Address into two subnets.\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a Network Address. Defaults to false.\n\t */\n\tpublic subdivide(requireNetwork: boolean = false): [Address, Address] {\n\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\n\t\t\tlet err = new Error(\"Not a Network Address\");\n\t\t\terr.name = ERROR_NOT_NETWORK;\n\t\t\tthrow err;\n\t\t}\n\n\t\tlet subnets: [Address, Address] = [undefined, undefined];\n\n\t\tif (this.maskShort === 32) {\n\t\t\treturn subnets;\n\t\t}\n\n\t\tlet ipBytes: Byte4;\n\n\t\tif (requireNetwork) {\n\t\t\tipBytes = cloneByte4(this.ip);\n\t\t}\n\t\telse {\n\t\t\tlet net = this.getNetworkAddress(true);\n\t\t\tipBytes = net.ip;\n\t\t}\n\n\t\tsubnets[0] = new Address(cloneByte4(ipBytes), this.maskShort+1);\n\t\t\n\t\tlet secondIpBytes: Byte4 = cloneByte4(ipBytes);\n\t\tlet {byteIndex, bitIndex} = splitBitIndex(this.maskShort);\n\t\tsecondIpBytes[byteIndex].bit(bitIndex, true);\n\n\t\tsubnets[1] = new Address(secondIpBytes, this.maskShort+1);\n\n\t\treturn subnets;\n\n\t}\n\t\n\t/**\n\t * Sets this Address' mask.\n\t * @param  {Byte4} mask The Byte4 mask to be set.\n\t */\n\tpublic setMask(mask: Byte4): void {\n\n\t\tlet maskShortTmp = 0;\n\t\tlet end = false;\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tfor (let j = 0; j < 8; j++) {\n\n\t\t\t\tif (mask[i].bit(8 - 1 - j)) {\n\t\t\t\t\tif(!end) {\n\t\t\t\t\t\tmaskShortTmp++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet err = new Error(\"Mask contains holes\");\n\t\t\t\t\t\terr.name = ERROR_MASK_HOLES;\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tend = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.maskShort = maskShortTmp;\n\t\tthis.mask = mask;\n\n\t}\n\n\t/**\n\t * Sets this Address' mask, given its numerical representation (0-32).\n\t * @param  {number} maskShort The numerical mask to be set.\n\t */\n\tpublic setMaskShort(maskShort: number): void {\n\n\t\tif (maskShort < 0 || maskShort > 32) {\n\t\t\tlet err = new RangeError(\"The short mask should be between 0 and 32\");\n\t\t\terr.name = ERROR_MASK_RANGE;\n\t\t\tthrow err;\n\t\t}\n\n\t\tlet tmpMask: Byte4 = Byte4Zero();\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tfor (let j = 0; j < 8; j++) {\n\t\t\t\tif (((8 * i) + j) < maskShort) {\n\t\t\t\t\ttmpMask[i].bit(8 - 1 - j, true);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttmpMask[i].bit(8 - 1 - j, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.maskShort = maskShort;\n\t\tthis.mask = tmpMask;\n\n\t}\n\n\t/**\n\t * Sets this Address' IP value.\n\t * @param  {Byte4} ip\n\t */\n\tpublic setIp(ip: Byte4): void {\n\t\tthis.ip = ip;\n\t}\n\n\t/**\n\t * Returns this Address' mask.\n\t */\n\tpublic getMask(): Byte4 {\n\t\treturn this.mask;\n\t}\n\n\t/**\n\t * Returns the numerical representation of this Address' mask.\n\t */\n\tpublic getMaskShort(): number {\n\t\treturn this.maskShort;\n\t}\n\t\n\t/**\n\t * Returns this Address' IP value.\n\t */\n\tpublic getIp(): Byte4 {\n\t\treturn this.ip;\n\t}\n\n\t/**\n\t * Sets this Address IP/Mask values from a parsed string.\n\t * @param  {string} address The full address, in the X.X.X.X/X format. If requireMask is false, the mask can be ommited and defaults to /0.\n\t * @param  {boolean=true} requireMask Whether the address requires the mask to be given.\n\t */\n\tpublic parseAddress(address: string, requireMask: boolean = true): void {\n\n\t\taddress = address.trim();\n\t\tconst fullRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\\/(\\d+)$/;\n\t\tconst ipRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/;\n\n\t\tlet match = fullRegex.exec(address);\n\n\t\tif (match !== null) {\n\t\t\tlet ipByte0 = new Byte(parseInt(match[1], 10));\n\t\t\tlet ipByte1 = new Byte(parseInt(match[2], 10));\n\t\t\tlet ipByte2 = new Byte(parseInt(match[3], 10));\n\t\t\tlet ipByte3 = new Byte(parseInt(match[4], 10));\n\t\t\tlet maskShort = parseInt(match[5], 10);\n\n\t\t\tif (maskShort < 0 || maskShort > 32) {\n\t\t\t\tlet err = new RangeError(\"The short mask should be between 0 and 32\");\n\t\t\t\terr.name = ERROR_MASK_RANGE;\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tthis.setIp([ipByte0, ipByte1, ipByte2, ipByte3]);\n\t\t\tthis.setMaskShort(maskShort);\n\t\t}\n\t\telse if (!requireMask) {\n\n\t\t\tlet matchIp = ipRegex.exec(address);\n\n\t\t\tif (matchIp !== null) {\n\t\t\t\tlet ipByte0 = new Byte(parseInt(matchIp[1], 10));\n\t\t\t\tlet ipByte1 = new Byte(parseInt(matchIp[2], 10));\n\t\t\t\tlet ipByte2 = new Byte(parseInt(matchIp[3], 10));\n\t\t\t\tlet ipByte3 = new Byte(parseInt(matchIp[4], 10));\n\n\t\t\t\tthis.setIp([ipByte0, ipByte1, ipByte2, ipByte3]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet err = new Error(\"Invalid IP/mask address string\");\n\t\t\t\terr.name = ERROR_ADDRESS_PARSE;\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tlet err = new Error(\"Invalid IP/mask address string\");\n\t\t\terr.name = ERROR_ADDRESS_PARSE;\n\t\t\tthrow err;\n\t\t}\n\n\t}\n\n\t\n\t/**\n\t * Returns the string representation of this Address in the X.X.X.X/X format.\n\t * @param  {boolean} omitMask Whether the mask should be ommited. Defaults to false.\n\t */\n\ttoString(omitMask: boolean = false): string {\n\n\t\treturn \"\" +\n\t\t\tthis.ip[0].getDecimal() + \".\" +\n\t\t\tthis.ip[1].getDecimal() + \".\" +\n\t\t\tthis.ip[2].getDecimal() + \".\" +\n\t\t\tthis.ip[3].getDecimal() + (omitMask? \"\" : this.shortMaskString());\n\n\t}\n\n\t/**\n\t * Returns the string representation of the mask.\n\t */\n\tmaskString(): string {\n\t\treturn \"\" +\n\t\t\tthis.mask[0].getDecimal() + \".\" +\n\t\t\tthis.mask[1].getDecimal() + \".\" +\n\t\t\tthis.mask[2].getDecimal() + \".\" +\n\t\t\tthis.mask[3].getDecimal();\n\t}\n\n\tshortMaskString(): string {\n\t\treturn \"/\" + this.getMaskShort();\n\t}\n\n}","/**\n * Shorthand for document.getElementById(id).\n * @param  {string} elementId String that specifies the ID value. Case-insensitive.\n */\nexport function id(elementId: string): HTMLElement {\n\treturn document.getElementById(elementId);\n}\n\n/**\n * Copies a string to the user's clipboard.\n * @param  {string} str String to be copied.\n * @param  {(success:boolean)=>void} done What happens on success/failure. Optional.\n */\nexport function copyToClipboard(str: string, done?: (success: boolean) => void): void {\n\n\tlet tmp = document.createElement(\"textarea\");\n\n\ttmp.style.position = 'fixed';\n\ttmp.style.top = \"0\";\n\ttmp.style.left = \"0\";\n\ttmp.style.opacity = \"0\";\n\ttmp.value = str;\n\n\tdocument.body.appendChild(tmp);\n\ttmp.focus();\n\ttmp.select();\n\n\tlet success = document.execCommand('copy');\n\tdocument.body.removeChild(tmp);\n\n\tif (done) {\n\t\tdone(success);\n\t}\n\n}\n\n/**\n * Creates an HTML element.\n * @param  {string} tagName The tag of the element, such as \"div\", \"span\", \"p\" etc.\n * @param  {string} classes The classes of the element. Optional.\n * @param  {string} text The text content of this element.\n * @param  {string} id The ID of this element.\n */\nexport function make(tagName: string, classes: string = undefined, text: string = undefined, id: string = undefined): HTMLElement {\n\n\tlet dom = document.createElement(tagName);\n\tif (classes !== undefined) {\n\t\tif (classes.length > 0) {\n\t\t\tdom.className = classes;\n\t\t}\n\t}\n\tif (text !== undefined) {\n\t\tdom.appendChild(textNode(text));\n\t}\n\tif (id !== undefined) {\n\t\tdom.id = id;\n\t}\n\treturn dom;\n}\n\n/**\n * This removes all children from the element.\n * @param  {HTMLElement} element The parent element.\n */\nexport function clearChildren(element: HTMLElement): void {\n\twhile (element.lastChild) element.removeChild(element.lastChild);\n}\n\n/**\n * Returns a text node, given a string.\n * @param  {string} text The text of the node.\n */\nexport function textNode(text: string): Text {\n\treturn document.createTextNode(text);\n}","export const NUMBERS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\n/**\n * Returns whether a character is a number.\n * @param  {string} str The character to be anyalized.\n*/\nexport function isCharNumeric(str: string): boolean {\n\treturn NUMBERS.indexOf(str) !== -1;\n}\n\n/**\n * Returns whether a string is composed of numbers only.\n * @param  {string} str The string to be anyalized.\n */\nexport function isStringNumeric(str: string): boolean {\n\tfor (let i = 0; i < str.length; i++) {\n\t\tif (!isCharNumeric(str.charAt(i)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n","// IPBits\n// +=========================+\n// Author: Henrique Colini\n// Version: 4.0 (2019-08-25)\n\nimport React, { Component, RefObject, ChangeEvent } from \"react\";\nimport { copyToClipboard } from \"../../../wireworks/utils/dom\";\nimport { isCharNumeric, isStringNumeric } from \"../../../wireworks/utils/string\";\nimport { clamp } from \"../../../wireworks/utils/math\";\nimport { Byte } from \"../../../wireworks/networking/byte\";\nimport { joinBitIndex, Address, Byte4Zero, splitBitIndex } from \"../../../wireworks/networking/layers/layer-3/address\";\nimport \"src/sass/pages/ipbits.scss\";\n\n/**\n * Keys that will not trigger keyUp/keyDown events.\n */\nconst additionalKeys = [\"Backspace\", \"Delete\", \"Tab\", \"ArrowLeft\", \"ArrowRight\", \"Home\", \"End\", \"Insert\"];\n\n// +==============================================+\n\nclass Ipbits extends Component {\n\n\t/**\n\t * The checkboxes corresponding to the IP bits.\n\t */\n\tprivate IP: RefObject<HTMLInputElement>[][] = [];\n\t/**\n\t * The checkboxes corresponding to the mask bits.\n\t */\n\tprivate MASK: RefObject<HTMLInputElement>[][] = [];\n\n\t/**\n\t * The mask displays.\n\t */\n\tprivate maskDisplays: RefObject<HTMLDivElement>[] = [];\n\n\t/**\n\t * The IP displays.\n\t */\n\tprivate ipDisplays: RefObject<HTMLInputElement>[] = [];\n\n\t/**\n\t * The short IP display.\n\t */\n\tprivate ipDisplayShort: RefObject<HTMLHeadingElement>;\n\n\t/**\n\t * The short mask display.\n\t */\n\tprivate maskDisplayShort: RefObject<HTMLHeadingElement>;\n\n\t/**\n\t * The button that copies the mask.\n\t */\n\tprivate copyMaskButton: RefObject<HTMLElement>;\n\n\t/**\n\t * The button that copies the IP.\n\t */\n\tprivate copyIPButton: RefObject<HTMLElement>;\n\n\t/**\n\t * The button that copies the mask.\n\t */\n\tprivate copyMaskText: RefObject<HTMLSpanElement>;\n\n\t/**\n\t * The button that copies the IP.\n\t */\n\tprivate copyIPText: RefObject<HTMLSpanElement>;\n\t\n\t/**\n\t * Returns the Address, extracted from the DOM elements.\n\t */\n\tprivate extractAddress(): Address {\n\n\t\tlet ipBytes = Byte4Zero()\n\t\tlet maskBytes = Byte4Zero()\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tfor (let j = 0; j < 8; j++) {\n\t\t\t\tipBytes[i].bit(j, (this.IP[i][j]).current.checked ? true : false);\n\t\t\t\tmaskBytes[i].bit(j, (this.MASK[i][j]).current.checked ? true : false);\n\t\t\t}\n\t\t}\n\n\t\treturn new Address(ipBytes,maskBytes);\n\n\t}\n\n\t/**\n\t * Sets the checkboxes and display of a DOM representation of a Byte, given a real one.\n\t * @param  {Byte} byte The byte to be displayed.\n\t * @param  {number} index The index of the 4 possible IP DOM bytes.\n\t * @param  {boolean} updateBig Whether the big displays should be updated as well. Defaults to true.\n\t * @param  {boolean} updateShort Whether the short display should be updated as well. Defaults to true.\n\t */\n\tprivate setIPByteDOM(byte: Byte, index: number, updateBig: boolean = true, updateShort: boolean = true): void {\n\t\t\n\t\tlet dom = this.IP[index];\n\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\n\t\t\tdom[i].current.checked = byte.bit(i);\n\t\t\t\n\t\t}\n\t\t\n\t\tif (updateBig) {\t\t\n\t\t\tthis.updateDisplays();\n\t\t}\n\t\telse if (updateShort) {\n\t\t\tthis.updateIPShort();\n\t\t}\n\n\t}\n\n\t/**\n\t * Updates the small IP display string.\n\t * @param  {string} str? The string to be shown. If not given, it will be calculated.\n\t */\n\tprivate updateIPShort(str?: string): void {\n\n\t\tthis.ipDisplayShort.current.textContent = str ? str : this.extractAddress().toString(true);\n\n\t}\n\n\t/**\n\t * Updates the small mask display string.\n\t * @param  {string} str? The string to be shown. If not given, it will be calculated.\n\t */\n\tprivate updateMaskShort(str?: string): void {\n\n\t\tthis.maskDisplayShort.current.textContent = str ? str : this.extractAddress().shortMaskString();\n\n\t}\n\n\t/**\n\t * Updates the big displays for the IP and mask.\n\t * @param  {Address} address? The address that will be displayed. If not given, it will be calculated.\n\t */\n\tprivate updateDisplays = (address?: Address): void => {\n\n\t\taddress = address? address : this.extractAddress();\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis.ipDisplays[i].current.value = \"\" + address.getIp()[i].getDecimal();\n\t\t\tthis.maskDisplays[i].current.textContent = \"\" + address.getMask()[i].getDecimal();\n\t\t}\n\n\t\tthis.updateIPShort(address.toString(true));\n\t\tthis.updateMaskShort(address.shortMaskString());\n\n\t}\n\n\t/**\n\t * Selects all the mask bit checkboxes until a given index.\n\t * @param  {number} index The last checked bit.\n\t */\n\tprivate selectMaskBit = (index: number): void => {\n\n\t\tlet { bitIndex, byteIndex } = splitBitIndex(index);\n\n\t\tindex += this.MASK[byteIndex][bitIndex].current.checked ? 1 : 0;\n\n\t\tfor (let byte4Index = 0; byte4Index < 32; byte4Index++) {\n\t\t\t\n\t\t\tlet { bitIndex, byteIndex } = splitBitIndex(byte4Index);\n\t\t\tlet on = byte4Index < index;\n\n\t\t\tthis.MASK[byteIndex][bitIndex].current.checked = on;\n\t\t\tthis.IP[byteIndex][bitIndex].current.disabled = on;\t\t\n\n\t\t}\n\n\t\tthis.updateDisplays();\n\n\t}\n\n\t/**\n\t * Copies the IP (in X.X.X.X format) to the clipboard.\n\t */\n\tprivate copyIPToClipboard = (): void => {\n\n\t\tlet scope: Ipbits = this;\n\n\t\tcopyToClipboard(this.extractAddress().toString(true), function (success: boolean): void {\n\n\t\t\tlet text = scope.copyIPText.current;\n\t\t\ttext.style.transition = \"\";\n\t\t\ttext.style.opacity = \"1\";\n\t\t\tsetTimeout(function () {\n\t\t\t\ttext.style.transition = \"opacity 1s\";\n\t\t\t\ttext.style.opacity = \"0\";\n\t\t\t}, 2000);\n\n\t\t});\n\n\t}\n\n\t/**\n\t * Copies the mask (in X.X.X.X format) to the clipboard.\n\t */\n\tprivate copyMaskToClipboard = (): void => {\n\n\t\tlet scope: Ipbits = this;\n\n\t\tcopyToClipboard(this.extractAddress().maskString(), function (success: boolean): void {\n\n\t\t\tlet text = scope.copyMaskText.current;\n\t\t\ttext.style.transition = \"\";\n\t\t\ttext.style.opacity = \"1\";\n\t\t\tsetTimeout(function () {\n\t\t\t\ttext.style.transition = \"opacity 1s\";\n\t\t\t\ttext.style.opacity = \"0\";\n\t\t\t}, 2000);\n\n\t\t});\n\n\t}\n\n\t/**\n\t * Handles IP bit clicking.\n\t */\n\thandleIPBitChange = () => {\n\t\tthis.updateDisplays();\n\t}\n\n\t/**\n\t * Handles mask bit clicking.\n\t */\n\thandleMaskBitChange = (byteIndex: number, bitIndex: number) => {\t\t\n\t\tthis.selectMaskBit(joinBitIndex(byteIndex, bitIndex));\n\t}\n\n\t/**\n\t * The byte that will be set after the last display gets blurred.\n\t */\n\tprivate blurByte: Byte;\n\n\t/**\n\t * Handles IP display focus.\n\t */\n\tprivate handleDisplayFocus = (display: HTMLInputElement, byteIndex: number): void => {\n\t\t\n\t\tdisplay.select();\n\n\t\tlet originalAddress = this.extractAddress();\n\t\tthis.blurByte = originalAddress.getIp()[byteIndex];\n\n\t}\n\n\t/**\n\t * Handles IP display blur.\n\t */\n\tprivate handleDisplayBlur = (byteIndex: number): void => {\n\t\tthis.setIPByteDOM(this.blurByte, byteIndex, true);\n\t}\n\n\t/**\n\t * Handles IP display key down.\n\t */\n\tprivate handleDisplayKeydown = (evt: React.KeyboardEvent<HTMLInputElement>, display: HTMLInputElement): void => { \n\t\t\n\t\tif (evt.key === \"Enter\") {\n\t\t\tdisplay.blur(); // only for UX, otherwise useless\n\t\t}\n\t\t\n\t\tif (additionalKeys.indexOf(evt.key) === -1 && !isCharNumeric(evt.key)){\t\t\t\t\n\t\t\tevt.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tlet selectedText = window.getSelection().anchorNode === display.parentNode ? window.getSelection().toString() : \"\";\n\n\t\tif (additionalKeys.indexOf(evt.key) === -1 && display.value.length >= 3 && selectedText === \"\")  evt.preventDefault();\n\n\t}\n\n\t/**\n\t * Handles IP display key up.\n\t */\n\tprivate handleDisplayKeyup = (evt: React.KeyboardEvent<HTMLInputElement>, display: HTMLInputElement, byteIndex: number): void => {\n\t\t\t\t\n\t\tlet next = byteIndex < 3 ? this.ipDisplays[byteIndex + 1].current : undefined;\n\n\t\tlet selectedText = window.getSelection().anchorNode === display.parentNode ? window.getSelection().toString() : \"\";\n\n\t\tif (additionalKeys.indexOf(evt.key) === -1 && display.value.length >= 3 && selectedText === \"\") {\n\n\t\t\tif (next) {\n\t\t\t\tnext.focus();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Handles IP display input.\n\t */\n\tprivate handleDisplayChange = (evt: ChangeEvent<HTMLInputElement>, display: HTMLInputElement, byteIndex: number): void => {\n\t\t\n\t\tif (display.value === \"\") {\n\t\t\t\t\t\t\n\t\t\tlet address = this.extractAddress();\n\n\t\t\tlet minByte = address.getIp()[byteIndex];\n\t\t\tlet mask = address.getMask()[byteIndex];\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif (!mask.bit(i)) {\n\t\t\t\t\tminByte.bit(i, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.blurByte = minByte;\n\n\t\t}\n\t\telse {\n\n\t\t\tif (isStringNumeric(display.value)){\n\n\t\t\t\tlet address = this.extractAddress();\n\n\t\t\t\tlet minByte = address.getIp()[byteIndex];\n\t\t\t\tlet maxByte = minByte.clone();\n\t\t\t\tlet mask = address.getMask()[byteIndex];\n\n\t\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\t\tif (!mask.bit(i)) {\n\t\t\t\t\t\tminByte.bit(i, false);\n\t\t\t\t\t\tmaxByte.bit(i, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet value = new Byte(\n\t\t\t\t\tclamp(\n\t\t\t\t\t\tparseInt(display.value, 10),\n\t\t\t\t\t\tminByte.getDecimal(),\n\t\t\t\t\t\tmaxByte.getDecimal()\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\tthis.blurByte = value;\n\t\t\t\tthis.setIPByteDOM(value, byteIndex, false);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tconstructor(props: any) {\n\t\t\n\t\tsuper(props);\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\n\t\t\tthis.maskDisplays[i] = React.createRef();\n\t\t\tthis.ipDisplays[i] = React.createRef();\n\t\t\tthis.MASK[i] = [];\n\t\t\tthis.IP[i] = [];\n\n\t\t\tfor (let j = 0; j < 8; j++) {\n\t\t\t\tthis.MASK[i][j] = React.createRef();\n\t\t\t\tthis.IP[i][j] = React.createRef();\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tthis.maskDisplayShort = React.createRef();\n\t\tthis.ipDisplayShort = React.createRef();\n\n\t\tthis.copyMaskButton = React.createRef();\n\t\tthis.copyIPButton = React.createRef();\n\t\tthis.copyMaskText = React.createRef();\n\t\tthis.copyIPText = React.createRef();\n\n\t}\n\n\tcomponentDidMount() {\t\t\n\t\tthis.updateDisplays();\n\t\tthis.updateIPShort();\n\t}\n\n\trender() {\n\n\t\tlet maskBox = [];\n\t\tlet ipBox = [];\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\n\t\t\tlet bitBox = [];\n\t\t\t\n\t\t\tfor (let j = 7; j >= 0; j--) {\n\t\t\t\tlet id = \"byte_mask_\"+i+\"_\"+j;\n\t\t\t\tbitBox.push(\n\t\t\t\t\t<div className=\"bit\" key={id+\"_bit\"}>\n\t\t\t\t\t\t<input tabIndex={-1} id={id} ref={this.MASK[i][j]} type=\"checkbox\" onChange={()=>{this.handleMaskBitChange(i,j)}}/>\n\t\t\t\t\t\t<label htmlFor={id}></label>\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tmaskBox.push(\n\t\t\t\t<div className=\"block\" key={\"mask_block_\"+i}>\n\t\t\t\t\t<div className=\"mask-display\" ref={this.maskDisplays[i]}>0</div>\n\t\t\t\t\t<div className=\"bit-box\"> { bitBox } </div>\n\t\t\t\t</div>\t\t\t\t\n\t\t\t);\n\t\t\tif (i < 3) maskBox.push(<div className=\"dot\" key={\"mask_dot_\"+i}></div>);\n\t\t\t\n\t\t}\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\n\t\t\tlet bitBox = [];\n\t\t\t\n\t\t\tfor (let j = 7; j >= 0; j--) {\n\t\t\t\tlet id = \"byte_ip_\"+i+\"_\"+j;\n\t\t\t\tbitBox.push(\n\t\t\t\t\t<div className=\"bit\" key={id+\"_bit\"}>\n\t\t\t\t\t\t<input tabIndex={-1} id={id} ref={this.IP[i][j]} type=\"checkbox\" onChange={this.handleIPBitChange}/>\n\t\t\t\t\t\t<label htmlFor={id}></label>\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tlet ipDisplay = <input\n\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\tclassName=\"display\"\n\t\t\t\t\t\t\t\tref={this.ipDisplays[i]}\n\t\t\t\t\t\t\t\tonChange={(evt) => {this.handleDisplayChange(evt, this.ipDisplays[i].current, i)}}\n\t\t\t\t\t\t\t\tonFocus={() => {this.handleDisplayFocus(this.ipDisplays[i].current, i)}}\n\t\t\t\t\t\t\t\tonBlur={() => {this.handleDisplayBlur(i)}}\n\t\t\t\t\t\t\t\tonKeyDown={(evt: React.KeyboardEvent<HTMLInputElement>) => {this.handleDisplayKeydown(evt, this.ipDisplays[i].current)}}\n\t\t\t\t\t\t\t\tonKeyUp={(evt: React.KeyboardEvent<HTMLInputElement>) => {this.handleDisplayKeyup(evt, this.ipDisplays[i].current, i)}}\n\t\t\t\t\t\t\t\t/>;\n\n\t\t\tipBox.push(\n\t\t\t\t<div className=\"block\" key={\"ip_block_\"+i}>\n\t\t\t\t\t{ ipDisplay }\n\t\t\t\t\t<div className=\"bit-box\"> { bitBox } </div>\n\t\t\t\t</div>\t\t\t\t\n\t\t\t);\n\t\t\tif (i < 3) ipBox.push(<div className=\"dot\" key={\"ip_dot_\"+i}></div>);\n\t\t\t\n\t\t}\n\n\t\treturn(\n\t\t\t<main>\n\t\t\t\t<div className=\"spacer\">\n\t\t\t\t\t<h2>Mscara <i className=\"far fa-clipboard copy-icon\" ref={this.copyMaskButton} onClick={this.copyMaskToClipboard}></i> <span className=\"copy-text\" ref={this.copyMaskText}>Mscara copiada</span></h2>\n\t\t\t\t\t<h2 className=\"text-light font-light\" ref={this.maskDisplayShort}>/0</h2>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t\t<div className=\"box\"> {maskBox} </div>\n\t\t\t\t\n\t\t\t\t<div className=\"spacer\">\n\t\t\t\t\t<h2>IP <i className=\"far fa-clipboard copy-icon\" ref={this.copyIPButton} onClick={this.copyIPToClipboard}></i> <span className=\"copy-text\" ref={this.copyIPText}>IP Copiado</span></h2>\n\t\t\t\t\t<h2 className=\"text-light font-light\" ref={this.ipDisplayShort}>0.0.0.0</h2>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t\t<div className=\"box\"> {ipBox} </div>\n\t\t\t</main>\n\n\t\t);\n\t}\n\n}\n\nexport default Ipbits;"],"sourceRoot":""}