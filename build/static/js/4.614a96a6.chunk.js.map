{"version":3,"sources":["app/wireworks/networking/byte.ts","app/wireworks/utils/math.ts","app/wireworks/networking/layers/layer-3/ip.ts","app/components/ErrorBox.tsx","app/pages/tools/layer-3/planner.tsx"],"names":["ByteZero","Byte","ByteMax","ERROR_BYTE_RANGE","value","Object","D_Henrique_Programming_Javascript_wireworks_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","this","bits","decimal","setDecimal","setBits","D_Henrique_Programming_Javascript_wireworks_github_io_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","key","Math","floor","err","RangeError","name","arr","length","bit8","i","undefined","booleanArrayToBit8","decimalToBinary","binaryToDecimal","index","arguments","slice","clamp","min","max","binary","reversed","realIndex","pow","tmpDecimal","reverse","__webpack_require__","d","__webpack_exports__","Byte4Zero","cloneByte4","byte4","clone","ERROR_MASK_RANGE","ERROR_ADDRESS_PARSE","ERROR_NOT_NETWORK","joinBitIndex","byteIndex","bitIndex","splitBitIndex","byte4Index","IP","ip","mask","requireMask","requireNetwork","maskShort","parseIP","setMaskShort","setMask","isNetworkAddress","Error","bytes","Array","minByte","maskByte","bit","maxByte","allowAbove30","compare","getNetworkAddress","getBroadcastAddress","other","j","ipBytes","maskBytes","net","getDecimal","subnets","secondIpBytes","_splitBitIndex","maskShortTmp","end","tmpMask","address","trim","match","exec","ipByte0","parseInt","ipByte1","ipByte2","ipByte3","setIp","matchIp","omitMask","shortMaskString","getMaskShort","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","ErrorBox","_ref","errorMessage","a","createElement","className","Planner","props","_this","D_Henrique_Programming_Javascript_wireworks_github_io_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","D_Henrique_Programming_Javascript_wireworks_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","call","txtAddress","btnGenerate","state","networkStr","maskStr","firstValidStr","lastValidStr","broadcastStr","hostsStr","showTable","createPlan","errStr","setState","current","error","toString","firstHost","lastHost","maskString","numberOfHosts","toLocaleString","network","broadcast","console","React","createRef","_this2","react__WEBPACK_IMPORTED_MODULE_5___default","htmlFor","type","ref","placeholder","onKeyDown","ev","onClick","_components_ErrorBox__WEBPACK_IMPORTED_MODULE_8__","Component"],"mappings":"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","file":"static/js/4.614a96a6.chunk.js","sourcesContent":["import { decimalToBinary, binaryToDecimal } from \"../utils/math\";\r\n\r\n/**\r\n * An array of 8 bits (boolean values).\r\n */\r\nexport type Bit8 = [boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean];\r\n\r\n/**\r\n * Returns a Bit8 filled with false.\r\n */\r\nexport function Bit8Zero(): Bit8 {\r\n\treturn [false, false, false, false, false, false, false, false];\r\n}\r\n\r\n/**\r\n * Returns a Bit8 filled with true.\r\n */\r\nexport function Bit8Max(): Bit8 {\r\n\treturn [true, true, true, true, true, true, true, true];\r\n}\r\n\r\n/**\r\n * Returns a Byte corresponding to the number 0.\r\n */\r\nexport function ByteZero(): Byte {\r\n\treturn new Byte(Bit8Zero());\r\n}\r\n\r\n/**\r\n * Returns a Byte corresponding to the number 255.\r\n */\r\nexport function ByteMax(): Byte {\r\n\treturn new Byte(Bit8Max());\r\n}\r\n\r\nexport function booleanArrayToBit8 (arr: boolean[]): Bit8 {\r\n\tif (arr.length > 8) {\r\n\t\tthrow new RangeError(\"The boolean array must have a length of 8 or less\");\r\n\t}\r\n\tlet bit8: Bit8 = Bit8Zero();\r\n\tfor (let i = 0; i < arr.length; i++) {\r\n\t\tbit8[i] = arr[i] !== undefined ? arr[i] : false;\r\n\t}\r\n\treturn bit8;\r\n}\r\n\r\n/**\r\n * Error name for a byte outside the correct range.\r\n */\r\nexport const ERROR_BYTE_RANGE = \"ByteRangeError\";\r\n\r\n/**\r\n * A Byte, composed of 8 bits (boolean values).\r\n * @author Henrique Colini\r\n */\r\nexport class Byte {\r\n\r\n\t/**\r\n\t * This Byte's Bit8 representation.\r\n\t */\t\r\n\tprivate bits: Bit8;\r\n\r\n\t/**\r\n\t * This Byte's numerical representation.\r\n\t */\r\n\tprivate decimal: number;\r\n\t\r\n\t/**\r\n\t * Constructs a Byte from a number (0-255) or a Bit8.\r\n\t * @constructor\r\n\t * @param  {number|Bit8} value The value of this Byte.\r\n\t */\r\n\r\n\tconstructor(value: number | Bit8) {\r\n\r\n\t\tif (typeof value === \"number\") {\r\n\t\t\tthis.setDecimal(value);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.setBits(value);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value of this Byte, using a number (0-255).\r\n\t * @param  {number} decimal\r\n\t */\r\n\r\n\tsetDecimal(decimal: number): void {\r\n\r\n\t\tif (decimal < 0 || decimal > 255 || decimal !== Math.floor(decimal)) {\r\n\t\t\tlet err = new RangeError(\"The decimal value of a byte must be an integer between 0-255 (inclusive)\");\r\n\t\t\terr.name = ERROR_BYTE_RANGE;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\tthis.bits = booleanArrayToBit8(decimalToBinary(decimal));\r\n\t\tthis.decimal = decimal;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value of this Byte, using a Bit8.\r\n\t * @param  {Bit8} bits\r\n\t */\r\n\r\n\tsetBits(bits: Bit8): void {\r\n\r\n\t\tthis.bits = bits;\r\n\t\tthis.decimal = binaryToDecimal(bits);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns this Byte's numeric value.\r\n\t */\r\n\r\n\tgetDecimal(): number {\r\n\t\treturn this.decimal;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns this Byte's Bit8 representation.\r\n\t */\r\n\r\n\tgetBits(): Bit8 {\r\n\t\treturn this.bits;\r\n\t}\r\n\r\n\t/**\r\n\t * Getter/Setter of a single bit from this Byte.\r\n\t * @param  {number} index The index of the bit.\r\n\t * @param  {boolean|undefined=undefined} value Optional. Sets the value for this bit.\r\n\t */\r\n\r\n\tbit(index: number, value: boolean | undefined = undefined): boolean {\r\n\r\n\t\tif (value !== undefined) {\r\n\t\t\tlet bits = this.bits;\r\n\t\t\tbits[index] = value;\r\n\t\t\tthis.setBits(bits);\r\n\t\t}\r\n\r\n\t\treturn this.bits[index];\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Clones this Byte.\r\n\t */\r\n\tclone(): Byte {\r\n\r\n\t\treturn new Byte(this.bits.slice() as Bit8)\r\n\r\n\t}\r\n\r\n}","/**\r\n * Returns a value, clamped between max and min.\r\n * @param  {number} value The number to be clamped.\r\n * @param  {number} min The minimum possible number.\r\n * @param  {number} max The maximum possible number.\r\n */\r\nexport function clamp(value: number, min: number, max: number): number {\r\n\treturn Math.min(Math.max(value, min), max);\r\n};\r\n\r\n/**\r\n * Converts a binary number (as a string, boolean array, or number array) to a decimal number.\r\n * @param  {boolean[]} binary The number to be converted. An array of booleans, read from left to right (e.g. 001 equals 4).\r\n * @param  {boolean} reversed Optional. Whether the input should be reversed (read from right to left). Defaults to false.\r\n */\r\nexport function binaryToDecimal(binary: boolean[], reversed: boolean = false): number {\r\n\r\n\tif (binary.length === 0) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tlet decimal = 0;\r\n\r\n\tfor (let realIndex = 0; realIndex < binary.length; realIndex++) {\r\n\r\n\t\tlet i = reversed ? binary.length - realIndex - 1 : realIndex;\r\n\r\n\t\tdecimal += binary[i] ? Math.pow(2, i) : 0;\r\n\t\t\r\n\t}\r\n\r\n\treturn decimal;\r\n\t\r\n}\r\n\r\n/**\r\n * Converts a decimal number (must be a positive integer) to an array of booleans (read from left to right, such that 001 equals 4).\r\n * @param  {number} decimal The number to be converted. Must be a positive integer.\r\n * @param  {boolean} reversed Optional. Whether the output should be reversed (read from right to left). Defaults to false.\r\n */\r\nexport function decimalToBinary(decimal: number, reversed: boolean = false): boolean[] {\r\n\r\n\tif (decimal < 0) {\r\n\t\tthrow new RangeError(\"Attempting to convert negative number to binary\");\r\n\t}\r\n\r\n\tif (decimal !== Math.floor(decimal)) {\r\n\t\tthrow new RangeError(\"Attempting to convert non-integer number to binary\");\r\n\t}\r\n\r\n\tlet binary: boolean[] = [];\r\n\r\n\tlet tmpDecimal = decimal, i = 0;\r\n\r\n\twhile (tmpDecimal > 0) {\r\n\r\n\t\tbinary[i] = tmpDecimal % 2 ? true : false;\r\n\t\ttmpDecimal = Math.floor(tmpDecimal / 2);\r\n\r\n\t\ti++;\r\n\r\n\t}\r\n\r\n\tif (reversed) {\r\n\t\tbinary.reverse();\r\n\t}\r\n\r\n\treturn binary;\r\n\r\n}","import { Byte, ByteZero, ByteMax } from \"../../byte\";\r\n\r\n/**\r\n * An array of 4 Bytes.\r\n */\r\nexport type Byte4 = [Byte,Byte,Byte,Byte];\r\n\r\n/**\r\n * Returns a Byte4 corresponding to 0, 0, 0, 0.\r\n */\r\nexport function Byte4Zero(): Byte4 {\r\n\treturn [ByteZero(), ByteZero(), ByteZero(), ByteZero()];\r\n}\r\n\r\n/**\r\n * Returns a Byte4 corresponding to 255, 255, 255, 255.\r\n */\r\nexport function Byte4Max(): Byte4 {\r\n\treturn [ByteMax(), ByteMax(), ByteMax(), ByteMax()];\r\n}\r\n\r\n/**\r\n * Clones a Byte4.\r\n * @param  {Byte4} byte4 The Byte4 to be cloned.\r\n */\r\nexport function cloneByte4(byte4: Byte4): Byte4 {\r\n\r\n\tbyte4 = byte4.slice() as Byte4;\r\n\r\n\tfor (let i = 0; i < 4; i++) {\r\n\t\tbyte4[i] = byte4[i].clone();\t\t\r\n\t}\r\n\r\n\treturn byte4;\r\n\r\n}\r\n\r\n/**\r\n * Error name for a mask with holes.\r\n */\r\nexport const ERROR_MASK_HOLES = \"MaskHolesError\";\r\n/**\r\n * Error name for a mask outside the correct range.\r\n */\r\nexport const ERROR_MASK_RANGE = \"MaskRangeError\";\r\n/**\r\n * Error name for a malformated address string.\r\n */\r\nexport const ERROR_ADDRESS_PARSE = \"AddressParseError\";\r\n/**\r\n * Error name for a when an IP Address should be a network address, but isn't.\r\n */\r\nexport const ERROR_NOT_NETWORK = \"NotNetworkError\";\r\n\r\n/**\r\n * Converts a bit in Byte index to a bit in Byte4 index.\r\n * @param  {number} byteIndex The index of the Byte in a Byte4.\r\n * @param  {number} bitIndex The index of the bit in the Byte.\r\n */\r\nexport function joinBitIndex(byteIndex: number, bitIndex: number): number {\r\n\tif (byteIndex > 3 || byteIndex < 0) {\r\n\t\tthrow new RangeError(\"The byteIndex must be between 0-3 (inclusive)\");\r\n\t}\r\n\tif (bitIndex > 7 || bitIndex < 0) {\r\n\t\tthrow new RangeError(\"The bitIndex must be between 0-7 (inclusive)\");\r\n\t}\r\n\treturn (8 * byteIndex) + (7 - bitIndex);\r\n}\r\n\r\n/**\r\n * Converts a bit in Byte4 index to a bit in Byte index.\r\n * @param  {number} byte4Index The index of the bit in a Byte4.\r\n */\r\nexport function splitBitIndex(byte4Index: number): { byteIndex: number, bitIndex: number } {\r\n\tif (byte4Index > 31 || byte4Index < 0) {\r\n\t\tthrow new RangeError(\"The byte4Index must be between 0-31 (inclusive)\");\r\n\t}\r\n\treturn {\r\n\t\tbyteIndex: Math.floor(byte4Index / 8),\r\n\t\tbitIndex: 7 - (byte4Index % 8)\r\n\t};\r\n}\r\n\r\n/**\r\n * A full IP/Mask address.\r\n * @author Henrique Colini\r\n */\r\nexport class IP {\r\n\t\r\n\t/**\r\n\t * This IP address's IP octets.\r\n\t */\r\n\tprivate ip: Byte4;\r\n\r\n\t/**\r\n\t * This IP address' mask.\r\n\t */\r\n\tprivate mask: Byte4;\r\n\r\n\t/**\r\n\t * The numerical representation of this IP address' mask.\r\n\t */\r\n\tprivate maskShort: number;\r\n\r\n\t\r\n\t/**\r\n\t * Constructs an IP address, given an IP and a mask.\r\n\t * @constructor\r\n\t * @param  {Byte4|string} ip The IP of this address. May be a Byte4 or a formatted string.\r\n\t * @param  {Byte4|number} mask Optional. The mask of this address. May be a Byte4 or its numerical representation. If not given, defaults to /0.\r\n\t * @param  {boolean} requireMask Optional. If set to true, the mask becomes a required parameter in the formatted string.\r\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a network address. Defaults to false.\r\n\t */\r\n\tconstructor(ip: Byte4 | string, mask?: Byte4 | number, requireMask: boolean = false, requireNetwork: boolean = false) {\r\n\r\n\t\tif (typeof ip === \"string\") {\r\n\t\t\tthis.parseIP(ip, requireMask);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.ip = ip;\r\n\t\t}\r\n\r\n\t\tif (!this.mask) {\r\n\t\t\tif (mask) {\r\n\t\t\t\tif (typeof mask === \"number\") {\r\n\t\t\t\t\tthis.setMaskShort(mask);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.setMask(mask);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.setMask(Byte4Zero());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\r\n\t\t\tlet err = new Error(\"Not a Network Address\");\r\n\t\t\terr.name = ERROR_NOT_NETWORK;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the network address of this IP Address.\r\n\t * @param {boolean} allowAbove30 Optional. If false, returns undefined if the mask is greater than 30. Defaults to false.\r\n\t */\r\n\tpublic getNetworkAddress(allowAbove30: boolean = false): IP {\r\n\r\n\t\tif (!allowAbove30 && this.maskShort > 30) return undefined;\r\n\r\n\t\tlet bytes: Byte4 = Array<Byte>(4) as Byte4;\r\n\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\r\n\t\t\tlet minByte = this.ip[i].clone();\r\n\t\t\tlet maskByte = this.mask[i];\r\n\r\n\t\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\t\tif (!maskByte.bit(i)) {\r\n\t\t\t\t\tminByte.bit(i, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbytes[i] = minByte;\r\n\r\n\t\t}\r\n\r\n\t\treturn new IP(bytes, cloneByte4(this.mask));\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the broadcast address of this IP Address' network.\r\n\t * @param {boolean} allowAbove30 Optional. If false, returns undefined if the mask is greater than 30. Defaults to false.\r\n\t */\r\n\tpublic getBroadcastAddress(allowAbove30: boolean = false): IP {\r\n\r\n\t\tif (!allowAbove30 && this.maskShort > 30) return undefined;\r\n\r\n\t\tlet bytes: Byte4 = Array<Byte>(4) as Byte4;\r\n\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\r\n\t\t\tlet maxByte = this.ip[i].clone();\r\n\t\t\tlet maskByte = this.mask[i];\r\n\r\n\t\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\t\tif (!maskByte.bit(i)) {\r\n\t\t\t\t\tmaxByte.bit(i, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbytes[i] = maxByte;\r\n\r\n\t\t}\r\n\r\n\t\treturn new IP(bytes, cloneByte4(this.mask));\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns whether this IP Address is a network address.\r\n\t * @param {boolean} allowAbove30 Optional. If false, returns false if the mask is greater than 30. Defaults to false.\r\n\t */\r\n\tpublic isNetworkAddress(allowAbove30: boolean = false): boolean {\r\n\t\treturn this.compare(this.getNetworkAddress(allowAbove30));\r\n\t};\r\n\r\n\t/**\r\n\t * Returns whether this IP Address is a broadcast address.\r\n\t * @param {boolean} allowAbove30 Optional. If false, returns false if the mask is greater than 30. Defaults to false.\r\n\t */\r\n\tpublic isBroadcastAddress(allowAbove30: boolean = false): boolean {\r\n\t\treturn this.compare(this.getBroadcastAddress(allowAbove30));\r\n\t};\r\n\t\r\n\t/**\r\n\t * Returns true if this IP Address is the same as another.\r\n\t * @param {IP} other the IP Address to be compared with.\r\n\t */\r\n\tpublic compare(other: IP): boolean {\r\n\r\n\t\tif (!other) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (this === other)\r\n\t\t\treturn true;\r\n\r\n\t\tif (this.ip === other.ip && (this.mask === other.mask || this.maskShort === other.maskShort))\r\n\t\t\treturn true;\r\n\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\t\tif ((this.ip[i].bit(j) !== other.ip[i].bit(j)) || (this.mask[i].bit(j) !== other.mask[i].bit(j))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns the amount of hosts that this IP Address' network has.\r\n\t * @param {boolean} requireNetwork Optional. If true, throws an error if this is not a network address. Defaults to false.\r\n\t */\r\n\tpublic numberOfHosts(requireNetwork: boolean = false): number {\r\n\r\n\t\tif(requireNetwork && !this.isNetworkAddress(true)) {\r\n\t\t\tlet err = new Error(\"Not a network address\");\r\n\t\t\terr.name = ERROR_NOT_NETWORK;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\tif (this.maskShort === 31)\r\n\t\t\treturn 2;\r\n\t\tif (this.maskShort === 32)\r\n\t\t\treturn 1;\r\n\t\treturn (Math.pow(2, 32 - this.maskShort) - 2);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the first valid host IP Address of this network.\r\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a network address. Defaults to false.\r\n\t */\r\n\tpublic firstHost(requireNetwork: boolean = false): IP {\r\n\r\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\r\n\t\t\tlet err = new Error(\"Not a network address\");\r\n\t\t\terr.name = ERROR_NOT_NETWORK;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\tlet ipBytes: Byte4;\r\n\t\tlet maskBytes: Byte4;\r\n\r\n\t\tif (requireNetwork) {\r\n\t\t\tipBytes = cloneByte4(this.ip);\r\n\t\t\tmaskBytes = cloneByte4(this.mask);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet net = this.getNetworkAddress(true);\r\n\t\t\tipBytes = net.ip;\r\n\t\t\tmaskBytes = net.mask;\r\n\t\t}\r\n\r\n\t\tif (this.maskShort < 31) {\r\n\t\t\tipBytes[3].setDecimal(ipBytes[3].getDecimal() + 1);\r\n\t\t}\r\n\r\n\t\treturn new IP(ipBytes, maskBytes);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last valid host IP Address of this network.\r\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a network address. Defaults to false.\r\n\t */\r\n\tpublic lastHost(requireNetwork: boolean = false): IP {\r\n\r\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\r\n\t\t\tlet err = new Error(\"Not a Network Address\");\r\n\t\t\terr.name = ERROR_NOT_NETWORK;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\tlet ipBytes: Byte4;\r\n\t\tlet maskBytes: Byte4;\r\n\r\n\t\tlet net = this.getBroadcastAddress(true);\r\n\t\tipBytes = net.ip;\r\n\t\tmaskBytes = net.mask;\r\n\r\n\t\tif (this.maskShort < 31) {\r\n\t\t\tipBytes[3].setDecimal(ipBytes[3].getDecimal() - 1);\r\n\t\t}\r\n\r\n\t\treturn new IP(ipBytes, maskBytes);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Divides this IP Address into two subnets.\r\n\t * @param  {boolean} requireNetwork Optional. If true, throws an error if this is not a network address. Defaults to false.\r\n\t */\r\n\tpublic subdivide(requireNetwork: boolean = false): [IP, IP] {\r\n\r\n\t\tif (requireNetwork && !this.isNetworkAddress(true)) {\r\n\t\t\tlet err = new Error(\"Not a Network Address\");\r\n\t\t\terr.name = ERROR_NOT_NETWORK;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\tlet subnets: [IP, IP] = [undefined, undefined];\r\n\r\n\t\tif (this.maskShort === 32) {\r\n\t\t\treturn subnets;\r\n\t\t}\r\n\r\n\t\tlet ipBytes: Byte4;\r\n\r\n\t\tif (requireNetwork) {\r\n\t\t\tipBytes = cloneByte4(this.ip);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet net = this.getNetworkAddress(true);\r\n\t\t\tipBytes = net.ip;\r\n\t\t}\r\n\r\n\t\tsubnets[0] = new IP(cloneByte4(ipBytes), this.maskShort+1);\r\n\t\t\r\n\t\tlet secondIpBytes: Byte4 = cloneByte4(ipBytes);\r\n\t\tlet {byteIndex, bitIndex} = splitBitIndex(this.maskShort);\r\n\t\tsecondIpBytes[byteIndex].bit(bitIndex, true);\r\n\r\n\t\tsubnets[1] = new IP(secondIpBytes, this.maskShort+1);\r\n\r\n\t\treturn subnets;\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Sets this IP Address' mask.\r\n\t * @param  {Byte4} mask The Byte4 mask to be set.\r\n\t */\r\n\tpublic setMask(mask: Byte4): void {\r\n\r\n\t\tlet maskShortTmp = 0;\r\n\t\tlet end = false;\r\n\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\tfor (let j = 0; j < 8; j++) {\r\n\r\n\t\t\t\tif (mask[i].bit(8 - 1 - j)) {\r\n\t\t\t\t\tif(!end) {\r\n\t\t\t\t\t\tmaskShortTmp++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlet err = new Error(\"Mask contains holes\");\r\n\t\t\t\t\t\terr.name = ERROR_MASK_HOLES;\r\n\t\t\t\t\t\tthrow err;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tend = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.maskShort = maskShortTmp;\r\n\t\tthis.mask = mask;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this IP Address' mask, given its numerical representation (0-32).\r\n\t * @param  {number} maskShort The numerical mask to be set.\r\n\t */\r\n\tpublic setMaskShort(maskShort: number): void {\r\n\r\n\t\tif (maskShort < 0 || maskShort > 32) {\r\n\t\t\tlet err = new RangeError(\"The short mask should be between 0 and 32\");\r\n\t\t\terr.name = ERROR_MASK_RANGE;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t\tlet tmpMask: Byte4 = Byte4Zero();\r\n\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\tfor (let j = 0; j < 8; j++) {\r\n\t\t\t\tif (((8 * i) + j) < maskShort) {\r\n\t\t\t\t\ttmpMask[i].bit(8 - 1 - j, true);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttmpMask[i].bit(8 - 1 - j, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.maskShort = maskShort;\r\n\t\tthis.mask = tmpMask;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this IP Address' IP value.\r\n\t * @param  {Byte4} ip\r\n\t */\r\n\tpublic setIp(ip: Byte4): void {\r\n\t\tthis.ip = ip;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns this IP Address' mask.\r\n\t */\r\n\tpublic getMask(): Byte4 {\r\n\t\treturn this.mask;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the numerical representation of this IP Address' mask.\r\n\t */\r\n\tpublic getMaskShort(): number {\r\n\t\treturn this.maskShort;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns this IP Address' IP value.\r\n\t */\r\n\tpublic getIp(): Byte4 {\r\n\t\treturn this.ip;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets this IP Address IP/Mask values from a parsed string.\r\n\t * @param  {string} address The full address, in the X.X.X.X/X format. If requireMask is false, the mask can be ommited and defaults to /0.\r\n\t * @param  {boolean=true} requireMask Whether the address requires the mask to be given.\r\n\t */\r\n\tpublic parseIP(address: string, requireMask: boolean = true): void {\r\n\r\n\t\taddress = address.trim();\r\n\t\tconst fullRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\\/(\\d+)$/;\r\n\t\tconst ipRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/;\r\n\r\n\t\tlet match = fullRegex.exec(address);\r\n\r\n\t\tif (match !== null) {\r\n\t\t\tlet ipByte0 = new Byte(parseInt(match[1], 10));\r\n\t\t\tlet ipByte1 = new Byte(parseInt(match[2], 10));\r\n\t\t\tlet ipByte2 = new Byte(parseInt(match[3], 10));\r\n\t\t\tlet ipByte3 = new Byte(parseInt(match[4], 10));\r\n\t\t\tlet maskShort = parseInt(match[5], 10);\r\n\r\n\t\t\tif (maskShort < 0 || maskShort > 32) {\r\n\t\t\t\tlet err = new RangeError(\"The short mask should be between 0 and 32\");\r\n\t\t\t\terr.name = ERROR_MASK_RANGE;\r\n\t\t\t\tthrow err;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setIp([ipByte0, ipByte1, ipByte2, ipByte3]);\r\n\t\t\tthis.setMaskShort(maskShort);\r\n\t\t}\r\n\t\telse if (!requireMask) {\r\n\r\n\t\t\tlet matchIp = ipRegex.exec(address);\r\n\r\n\t\t\tif (matchIp !== null) {\r\n\t\t\t\tlet ipByte0 = new Byte(parseInt(matchIp[1], 10));\r\n\t\t\t\tlet ipByte1 = new Byte(parseInt(matchIp[2], 10));\r\n\t\t\t\tlet ipByte2 = new Byte(parseInt(matchIp[3], 10));\r\n\t\t\t\tlet ipByte3 = new Byte(parseInt(matchIp[4], 10));\r\n\r\n\t\t\t\tthis.setIp([ipByte0, ipByte1, ipByte2, ipByte3]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet err = new Error(\"Invalid IP/mask address string\");\r\n\t\t\t\terr.name = ERROR_ADDRESS_PARSE;\r\n\t\t\t\tthrow err;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet err = new Error(\"Invalid IP/mask address string\");\r\n\t\t\terr.name = ERROR_ADDRESS_PARSE;\r\n\t\t\tthrow err;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Returns the string representation of this IP Address in the X.X.X.X/X format.\r\n\t * @param  {boolean} omitMask Whether the mask should be ommited. Defaults to false.\r\n\t */\r\n\ttoString(omitMask: boolean = false): string {\r\n\r\n\t\treturn \"\" +\r\n\t\t\tthis.ip[0].getDecimal() + \".\" +\r\n\t\t\tthis.ip[1].getDecimal() + \".\" +\r\n\t\t\tthis.ip[2].getDecimal() + \".\" +\r\n\t\t\tthis.ip[3].getDecimal() + (omitMask? \"\" : this.shortMaskString());\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the string representation of the mask.\r\n\t */\r\n\tmaskString(): string {\r\n\t\treturn \"\" +\r\n\t\t\tthis.mask[0].getDecimal() + \".\" +\r\n\t\t\tthis.mask[1].getDecimal() + \".\" +\r\n\t\t\tthis.mask[2].getDecimal() + \".\" +\r\n\t\t\tthis.mask[3].getDecimal();\r\n\t}\r\n\r\n\tshortMaskString(): string {\r\n\t\treturn \"/\" + this.getMaskShort();\r\n\t}\r\n\r\n}","import React, { FC } from \"react\";\r\n\r\ninterface ErrorBoxProps {\r\n\terrorMessage: string\r\n}\r\n\r\nconst ErrorBox: FC<ErrorBoxProps> = ({errorMessage}) => {\r\n\r\n    if (errorMessage) {\r\n        return (\r\n            <div className=\"errorbox\">{errorMessage}</div>\r\n        );\r\n    }\r\n\r\n    return null;\r\n\r\n}\r\n\r\nexport default ErrorBox;","// Planner\r\n// +=========================+\r\n// Author: Henrique Colini\r\n// Version: 3.1 (2019-08-29)\r\n\r\nimport React, { Component, RefObject } from \"react\";\r\nimport { IP, ERROR_NOT_NETWORK, ERROR_ADDRESS_PARSE, ERROR_MASK_RANGE } from \"../../../wireworks/networking/layers/layer-3/ip\";\r\nimport { ERROR_BYTE_RANGE } from \"../../../wireworks/networking/byte\";\r\nimport ErrorBox from \"../../../components/ErrorBox\";\r\nimport \"src/sass/pages/planner.scss\";\r\n\r\n// +==============================================+\r\n\r\nclass Planner extends Component {\r\n\r\n\t/**\r\n\t * The reference to the address input.\r\n\t */\r\n\tprivate txtAddress: RefObject<HTMLInputElement>;\r\n\t/**\r\n\t * The reference to the generate button.\r\n\t */\r\n\tprivate btnGenerate: RefObject<HTMLButtonElement>;\r\n\r\n\tstate = {\r\n\t\terrorMessage: undefined,\r\n\t\tnetworkStr: \"\",\r\n\t\tmaskStr: \"\",\r\n\t\tfirstValidStr: \"\",\r\n\t\tlastValidStr: \"\",\r\n\t\tbroadcastStr: \"\",\r\n\t\thostsStr: \"\",\r\n\t\tshowTable: false\r\n\t};\r\n\r\n\t/**\r\n\t * Creates a networking plan.\r\n\t */\r\n\tprivate createPlan = () => {\r\n\r\n\t\tlet errStr: string = undefined;\r\n\t\tthis.setState({errorMessage: undefined});\r\n\t\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\tlet address = new IP(this.txtAddress.current.value);\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\taddress = new IP(this.txtAddress.current.value, undefined, true, true);\r\n\t\r\n\t\t\t} catch (error) {\r\n\t\r\n\t\t\t\tif (error.name === ERROR_NOT_NETWORK) {\r\n\t\t\t\t\terrStr = \"Este não é um endereço de rede. Você quis dizer \" + address.getNetworkAddress(true).toString() + \"?\";\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthrow error;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setState({firstValidStr: address.firstHost(true).toString(true)});\r\n\t\t\tthis.setState({lastValidStr: address.lastHost(true).toString(true)});\r\n\t\t\tthis.setState({maskStr: address.maskString()})\t\r\n\t\t\tthis.setState({hostsStr: '' + address.numberOfHosts().toLocaleString()});\r\n\t\t\t\r\n\t\t\tlet network = address.getNetworkAddress();\r\n\t\t\tlet broadcast = address.getBroadcastAddress();\r\n\t\t\t\r\n\t\t\tthis.setState({networkStr: network ? network.toString() : \"N/A\"});\r\n\t\t\tthis.setState({broadcastStr: broadcast ? broadcast.toString(true) : \"N/A\"});\r\n\t\t\t\r\n\t\t\tthis.setState({showTable: true});\r\n\t\t\r\n\t\t} catch (error) {\r\n\t\t\t\r\n\t\t\tif(!errStr){\r\n\t\t\t\t\r\n\t\t\t\tswitch (error.name) {\r\n\t\t\t\t\tcase ERROR_ADDRESS_PARSE:\r\n\t\t\t\t\t\terrStr = \"A entrada deve possuir o formato 0.0.0.0/0.\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase ERROR_MASK_RANGE:\r\n\t\t\t\t\t\terrStr = \"O valor da máscara é alto demais (deve estar entre 0-32).\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase ERROR_BYTE_RANGE:\r\n\t\t\t\t\t\terrStr = \"Um ou mais octetos possui um valor alto demais (deve estar entre 0-255).\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\terrStr = \"Erro desconhecido (\" + error.name + \").\";\r\n\t\t\t\t\t\tconsole.error(error);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setState({showTable: false})\r\n\t\t\tthis.setState({errorMessage: \"Entrada inválida. \" + errStr})\r\n\t\r\n\t\t}\t\r\n\t\t\t\r\n\t}\r\n\t\r\n\tconstructor(props: any) {\r\n\t\tsuper(props);\r\n\t\tthis.txtAddress = React.createRef();\r\n\t\tthis.btnGenerate = React.createRef();\r\n\t}\r\n\r\n    render() {\r\n        return (\r\n            <main>\r\n\t\t\t\t<label htmlFor=\"address\">Rede/Máscara</label>\r\n\t\t\t\t<h1>\r\n\t\t\t\t\t<input type=\"text\" name=\"address\" ref={this.txtAddress} placeholder=\"0.0.0.0/0\" onKeyDown={(ev) => {if (ev.key === \"Enter\") this.createPlan()}}/>\r\n\t\t\t\t\t<button type=\"button\" ref={this.btnGenerate} onClick={this.createPlan}>Gerar plano</button>\r\n\t\t\t\t</h1>\r\n\t\t\t\t<ErrorBox errorMessage={this.state.errorMessage}/>\r\n\t\t\t\t{ this.state.showTable &&\r\n\t\t\t\t\t<table>\r\n\t\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<th>Rede</th>\r\n\t\t\t\t\t\t\t<th>Máscara</th>\r\n\t\t\t\t\t\t\t<th>Primeiro Válido</th>\r\n\t\t\t\t\t\t\t<th>Último Válido</th>\r\n\t\t\t\t\t\t\t<th>Broadcast</th>\r\n\t\t\t\t\t\t\t<th>Hosts</th>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t<td>{this.state.networkStr}</td>\r\n\t\t\t\t\t\t\t<td>{this.state.maskStr}</td>\r\n\t\t\t\t\t\t\t<td>{this.state.firstValidStr}</td>\r\n\t\t\t\t\t\t\t<td>{this.state.lastValidStr}</td>\r\n\t\t\t\t\t\t\t<td>{this.state.broadcastStr}</td>\r\n\t\t\t\t\t\t\t<td>{this.state.hostsStr}</td>\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t</tbody>\r\n\t\t\t\t\t</table>\r\n\t\t\t\t}\r\n\t\t\t</main>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Planner;"],"sourceRoot":""}